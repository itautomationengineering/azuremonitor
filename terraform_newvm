###############################################################################
# Terraform + Provider
###############################################################################
terraform {
  required_version = ">= 1.6.0"
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = ">= 3.112.0"
    }
  }
}

provider "azurerm" {
  features {}
}

###############################################################################
# Variables (mirrors your ARM parameters)
###############################################################################
variable "location"                      { type = string }
variable "networkInterfaceName1"         { type = string }
variable "enableAcceleratedNetworking"   { type = bool }
variable "networkSecurityGroupName"      { type = string }
variable "networkSecurityGroupRules"     { type = list(any) }           # ARM-style rule objects (see notes)
variable "subnetName"                    { type = string }
variable "virtualNetworkName"            { type = string }
variable "addressPrefixes"               { type = list(string) }
variable "subnets"                       { type = list(any) }            # [{name, addressPrefix, nsg?, routeTable?}, ...]
variable "publicIpAddressName1"          { type = string }
variable "publicIpAddressType"           { type = string }               # "Static" | "Dynamic"
variable "publicIpAddressSku"            { type = string }               # "Standard" | "Basic"
variable "pipDeleteOption"               { type = string }               # not directly supported in TF (see notes)
variable "virtualMachineName"            { type = string }               # used by alerts
variable "virtualMachineName1"           { type = string }
variable "virtualMachineComputerName1"   { type = string }
variable "virtualMachineRG"              { type = string }               # resource group name for nested deployments (alerts)
variable "osDiskType"                    { type = string }               # e.g., "Premium_LRS"
variable "osDiskDeleteOption"            { type = string }               # "Delete" | "Detach"
variable "virtualMachineSize"            { type = string }               # e.g., "Standard_B2ms"
variable "nicDeleteOption"               { type = string }               # not directly supported in TF (see notes)
variable "hibernationEnabled"            { type = bool }
variable "adminUsername"                 { type = string }
variable "adminPassword"                 { type = string }               # secure
variable "patchMode"                     { type = string }               # e.g., "AutomaticByOS"
variable "enablePeriodicAssessment"      { type = string }               # "AutomaticByPlatform" | "ImageDefault"
variable "enableHotpatching"             { type = bool }
variable "securityType"                  { type = string }               # e.g., "TrustedLaunch" | "Standard"
variable "secureBoot"                    { type = bool }
variable "vTPM"                          { type = bool }
variable "diagnosticsStorageAccountName" { type = string }
variable "diagnosticsStorageAccountType" { type = string }               # e.g., "Standard_LRS"
variable "diagnosticsStorageAccountKind" { type = string }               # e.g., "StorageV2"
variable "virtualMachine1Zone"           { type = string }               # "1" | "2" | "3" or ""
variable "autoShutdownStatus"            { type = string }               # "Enabled" | "Disabled"
variable "autoShutdownTime"              { type = string }               # "19:00"
variable "autoShutdownTimeZone"          { type = string }               # e.g., "Pacific Standard Time"
variable "autoShutdownNotificationStatus"{ type = string }               # "Enabled" | "Disabled"
variable "autoShutdownNotificationLocale"{ type = string }               # e.g., "en"
variable "autoShutdownNotificationEmail" { type = string }
variable "healthExtensionProtocol"       { type = string }               # "http" | "https" | "tcp"
variable "healthExtensionPort"           { type = number }
variable "healthExtensionInterval"       { type = number }
variable "healthExtensionNumberOfProbes" { type = number }
variable "healthExtensionRequestPath"    { type = string }

# Optional: resource group (ARM template assumes current RG). Add if you need to create one here.
variable "resource_group_name" { type = string }

###############################################################################
# Networking: VNet, Subnets, NSG, Public IP, NIC
###############################################################################
resource "azurerm_virtual_network" "vnet" {
  name                = var.virtualNetworkName
  location            = var.location
  resource_group_name = var.resource_group_name
  address_space       = var.addressPrefixes
}

# Create each subnet from ARM "subnets" array
resource "azurerm_subnet" "subnets" {
  for_each             = { for s in var.subnets : s.name => s }
  name                 = each.value.name
  resource_group_name  = var.resource_group_name
  virtual_network_name = azurerm_virtual_network.vnet.name
  address_prefixes     = try([each.value.properties.addressPrefix], try(each.value.addressPrefixes, []))
}

# NSG
resource "azurerm_network_security_group" "nsg" {
  name                = var.networkSecurityGroupName
  location            = var.location
  resource_group_name = var.resource_group_name
}

# NSG rules from ARM-style array
resource "azurerm_network_security_rule" "nsg_rules" {
  for_each                    = { for r in var.networkSecurityGroupRules : r.name => r }
  name                        = each.value.name
  priority                    = tonumber(try(each.value.properties.priority, each.value.priority))
  direction                   = upper(try(each.value.properties.direction, each.value.direction))
  access                      = upper(try(each.value.properties.access, each.value.access))
  protocol                    = lower(try(each.value.properties.protocol, each.value.protocol)) == "*" ? "*" : upper(try(each.value.properties.protocol, each.value.protocol))
  source_port_range           = try(each.value.properties.sourcePortRange, each.value.sourcePortRange, null)
  destination_port_range      = try(each.value.properties.destinationPortRange, each.value.destinationPortRange, null)
  source_port_ranges          = try(each.value.properties.sourcePortRanges, each.value.sourcePortRanges, null)
  destination_port_ranges     = try(each.value.properties.destinationPortRanges, each.value.destinationPortRanges, null)
  source_address_prefix       = try(each.value.properties.sourceAddressPrefix, each.value.sourceAddressPrefix, null)
  destination_address_prefix  = try(each.value.properties.destinationAddressPrefix, each.value.destinationAddressPrefix, null)
  source_address_prefixes     = try(each.value.properties.sourceAddressPrefixes, each.value.sourceAddressPrefixes, null)
  destination_address_prefixes= try(each.value.properties.destinationAddressPrefixes, each.value.destinationAddressPrefixes, null)
  resource_group_name         = var.resource_group_name
  network_security_group_name = azurerm_network_security_group.nsg.name
}

# Public IP
resource "azurerm_public_ip" "pip1" {
  name                = var.publicIpAddressName1
  location            = var.location
  resource_group_name = var.resource_group_name
  allocation_method   = var.publicIpAddressType              # "Static" | "Dynamic"
  sku                 = var.publicIpAddressSku               # "Standard" | "Basic"
  zones               = var.virtualMachine1Zone != "" ? [var.virtualMachine1Zone] : null
}

# NIC
resource "azurerm_network_interface" "nic1" {
  name                = var.networkInterfaceName1
  location            = var.location
  resource_group_name = var.resource_group_name
  enable_accelerated_networking = var.enableAcceleratedNetworking

  ip_configuration {
    name                          = "ipconfig1"
    subnet_id                     = azurerm_subnet.subnets[var.subnetName].id
    private_ip_address_allocation = "Dynamic"
    public_ip_address_id          = azurerm_public_ip.pip1.id
  }

  # Note: ARM 'deleteOption' on NIC/IP association isn't exposed in azurerm.
  # TF handles lifecycle via 'delete_os_disk_on_termination' etc. on the VM.
}

# Optional: associate NSG to NIC (ARM attached NSG via NIC-level reference)
resource "azurerm_network_interface_security_group_association" "nic_nsg" {
  network_interface_id      = azurerm_network_interface.nic1.id
  network_security_group_id = azurerm_network_security_group.nsg.id
}

###############################################################################
# Storage Account for legacy IaaS Diagnostics extension
###############################################################################
resource "azurerm_storage_account" "diag" {
  name                     = var.diagnosticsStorageAccountName
  resource_group_name      = var.resource_group_name
  location                 = var.location
  account_kind             = var.diagnosticsStorageAccountKind
  account_tier             = upper(split("_", var.diagnosticsStorageAccountType)[0])   # e.g., "Standard"
  account_replication_type = upper(split("_", var.diagnosticsStorageAccountType)[1])   # e.g., "LRS"
  min_tls_version          = "TLS1_2"
}

###############################################################################
# Windows VM
###############################################################################
resource "azurerm_windows_virtual_machine" "vm" {
  name                = var.virtualMachineName1
  location            = var.location
  resource_group_name = var.resource_group_name
  size                = var.virtualMachineSize

  admin_username = var.adminUsername
  admin_password = var.adminPassword

  network_interface_ids = [azurerm_network_interface.nic1.id]
  zone                  = var.virtualMachine1Zone != "" ? var.virtualMachine1Zone : null

  os_disk {
    caching              = "ReadWrite"
    storage_account_type = var.osDiskType
    disk_size_gb         = null
    name                 = "${var.virtualMachineName1}-osdisk"
    # Deletion behavior
    delete_option        = var.osDiskDeleteOption  # "Delete" or "Detach"
  }

  # Boot diagnostics: managed (matches ARM 'enabled': true without supplying a storage URI)
  boot_diagnostics {
    storage_account_uri = null
  }

  # Security profile
  security_type       = var.securityType           # "TrustedLaunch" or "Standard"
  secure_boot_enabled = var.secureBoot
  vtpm_enabled        = var.vTPM

  # Hibernation
  hibernation_enabled = var.hibernationEnabled

  # Computer name & patch settings
  computer_name = var.virtualMachineComputerName1

  patch_mode                   = var.patchMode                   # "AutomaticByOS", etc.
  assessment_mode              = var.enablePeriodicAssessment    # "AutomaticByPlatform" | "ImageDefault"
  hotpatching_enabled          = var.enableHotpatching

  # Image: Windows Server 2019 Gen2
  source_image_reference {
    publisher = "MicrosoftWindowsServer"
    offer     = "WindowsServer"
    sku       = "2019-datacenter-gensecond"
    version   = "latest"
  }

  identity {
    type = "SystemAssigned"
  }
}

###############################################################################
# Legacy IaaS Diagnostics Extension (Microsoft.Azure.Diagnostics/IaaSDiagnostics)
###############################################################################
# This mirrors your ARM extension. It pushes counters + event logs to the Storage Account above.
data "azurerm_storage_account_sas" "diag_sas" {
  connection_string = azurerm_storage_account.diag.primary_connection_string
  https_only        = true
  start             = timestamp()
  expiry            = timeadd(timestamp(), "24h")  # not used directly; we just need account key below if desired
  resource_types {
    service   = true
    container = true
    object    = true
  }
  services {
    blob  = true
    queue = false
    table = false
    file  = false
  }
  permissions {
    read    = true
    write   = true
    delete  = false
    list    = true
    add     = true
    create  = true
    update  = true
    process = false
    tag     = false
    filter  = false
  }
}

# We need the account key for protected settings:
data "azurerm_storage_account" "diag" {
  name                = azurerm_storage_account.diag.name
  resource_group_name = var.resource_group_name
}

resource "azurerm_virtual_machine_extension" "iaas_diagnostics" {
  name                 = "Microsoft.Insights.VMDiagnosticsSettings"
  virtual_machine_id   = azurerm_windows_virtual_machine.vm.id
  publisher            = "Microsoft.Azure.Diagnostics"
  type                 = "IaaSDiagnostics"
  type_handler_version = "1.5"
  auto_upgrade_minor_version = true

  settings = jsonencode({
    StorageAccount = var.diagnosticsStorageAccountName
    WadCfg = {
      DiagnosticMonitorConfiguration = {
        overallQuotaInMB = 5120
        Metrics = {
          resourceId = azurerm_windows_virtual_machine.vm.id
          MetricAggregation = [
            { scheduledTransferPeriod = "PT1H" },
            { scheduledTransferPeriod = "PT1M" }
          ]
        }
        DiagnosticInfrastructureLogs = {
          scheduledTransferLogLevelFilter = "Error"
        }
        PerformanceCounters = {
          scheduledTransferPeriod = "PT1M"
          PerformanceCounterConfiguration = [
            # (Trimmed to keep readable. You can paste your full list here 1:1.)
            { counterSpecifier = "\\Processor Information(_Total)\\% Processor Time", unit = "Percent",     sampleRate = "PT60S" },
            { counterSpecifier = "\\Memory\\Available Bytes",                             unit = "Bytes",      sampleRate = "PT60S" },
            { counterSpecifier = "\\LogicalDisk(_Total)\\% Free Space",                   unit = "Percent",    sampleRate = "PT60S" },
            { counterSpecifier = "\\Network Interface(*)\\Bytes Total/sec",               unit = "BytesPerSecond", sampleRate = "PT60S" }
          ]
        }
        WindowsEventLog = {
          scheduledTransferPeriod = "PT1M"
          DataSource = [
            { name = "Application!*[System[(Level = 1 or Level = 2 or Level = 3)]]" },
            { name = "Security!*[System[band(Keywords,4503599627370496)]]" },
            { name = "System!*[System[(Level = 1 or Level = 2 or Level = 3)]]" }
          ]
        }
      }
    }
  })

  protected_settings = jsonencode({
    storageAccountName     = var.diagnosticsStorageAccountName
    storageAccountKey      = data.azurerm_storage_account.diag.primary_access_key
    storageAccountEndPoint = "https://core.windows.net/"
  })
}

###############################################################################
# Application Health Extension (Windows)
###############################################################################
resource "azurerm_virtual_machine_extension" "app_health" {
  name                 = "HealthExtension"
  virtual_machine_id   = azurerm_windows_virtual_machine.vm.id
  publisher            = "Microsoft.ManagedServices"
  type                 = "ApplicationHealthWindows"
  type_handler_version = "1.0"
  auto_upgrade_minor_version = true

  settings = jsonencode({
    protocol          = var.healthExtensionProtocol
    port              = var.healthExtensionPort
    intervalInSeconds = var.healthExtensionInterval
    numberOfProbes    = var.healthExtensionNumberOfProbes
    requestPath       = var.healthExtensionRequestPath
  })

  depends_on = [azurerm_virtual_machine_extension.iaas_diagnostics]
}

###############################################################################
# Auto-shutdown (DevTest Labs Global VM Shutdown Schedule)
###############################################################################
# ARM uses Microsoft.DevTestLab/schedules. In Terraform, use the global schedule resource:
resource "azurerm_dev_test_global_vm_shutdown_schedule" "shutdown" {
  virtual_machine_id = azurerm_windows_virtual_machine.vm.id
  enabled            = (lower(var.autoShutdownStatus) == "enabled")

  daily_recurrence_time = var.autoShutdownTime            # e.g., "1900"
  timezone              = var.autoShutdownTimeZone        # e.g., "Pacific Standard Time"

  notification_settings {
    enabled                = (lower(var.autoShutdownNotificationStatus) == "enabled")
    time_in_minutes        = 30
    webhook_url            = null
    email                  = var.autoShutdownNotificationEmail
  }
}

###############################################################################
# Alerts: Action Group + Metric Alerts (CPU, Mem, Disk IOPS, Net In/Out, Availability)
###############################################################################
resource "azurerm_monitor_action_group" "ag" {
  name                = "RecommendedAlertRules-AG-1"
  resource_group_name = var.resource_group_name
  short_name          = "recalert1"

  email_receiver {
    name                    = "Email0_-EmailAction-"
    email_address           = var.autoShutdownNotificationEmail
    use_common_alert_schema = true
  }
}

# Helper locals for repeated alert fields
locals {
  vm_scope = [azurerm_windows_virtual_machine.vm.id]
}

# CPU > threshold (Average over 5m)
resource "azurerm_monitor_metric_alert" "cpu" {
  name                = "Percentage CPU - ${var.virtualMachineName1}"
  resource_group_name = var.resource_group_name
  scopes              = local.vm_scope
  description         = "CPU usage high"
  severity            = 3
  enabled             = true
  frequency           = "PT5M"
  window_size         = "PT5M"

  criteria {
    metric_namespace = "Microsoft.Compute/virtualMachines"
    metric_name      = "Percentage CPU"
    aggregation      = "Average"
    operator         = "GreaterThan"
    threshold        = 80
  }

  action {
    action_group_id = azurerm_monitor_action_group.ag.id
  }
}

# Available Memory Bytes < threshold
resource "azurerm_monitor_metric_alert" "mem" {
  name                = "Available Memory Bytes - ${var.virtualMachineName1}"
  resource_group_name = var.resource_group_name
  scopes              = local.vm_scope
  severity            = 3
  enabled             = true
  frequency           = "PT5M"
  window_size         = "PT5M"

  criteria {
    metric_namespace = "Microsoft.Compute/virtualMachines"
    metric_name      = "Available Memory Bytes"
    aggregation      = "Average"
    operator         = "LessThan"
    threshold        = 1000000000
  }

  action { action_group_id = azurerm_monitor_action_group.ag.id }
}

# Data Disk IOPS Consumed Percentage > 95
resource "azurerm_monitor_metric_alert" "data_iops" {
  name                = "Data Disk IOPS Consumed Percentage - ${var.virtualMachineName1}"
  resource_group_name = var.resource_group_name
  scopes              = local.vm_scope
  severity            = 3
  enabled             = true
  frequency           = "PT5M"
  window_size         = "PT5M"

  criteria {
    metric_namespace = "Microsoft.Compute/virtualMachines"
    metric_name      = "Data Disk IOPS Consumed Percentage"
    aggregation      = "Average"
    operator         = "GreaterThan"
    threshold        = 95
  }

  action { action_group_id = azurerm_monitor_action_group.ag.id }
}

# OS Disk IOPS Consumed Percentage > 95
resource "azurerm_monitor_metric_alert" "os_iops" {
  name                = "OS Disk IOPS Consumed Percentage - ${var.virtualMachineName1}"
  resource_group_name = var.resource_group_name
  scopes              = local.vm_scope
  severity            = 3
  enabled             = true
  frequency           = "PT5M"
  window_size         = "PT5M"

  criteria {
    metric_namespace = "Microsoft.Compute/virtualMachines"
    metric_name      = "OS Disk IOPS Consumed Percentage"
    aggregation      = "Average"
    operator         = "GreaterThan"
    threshold        = 95
  }

  action { action_group_id = azurerm_monitor_action_group.ag.id }
}

# Network In Total > threshold (Total over 5m)
resource "azurerm_monitor_metric_alert" "net_in" {
  name                = "Network In Total - ${var.virtualMachineName1}"
  resource_group_name = var.resource_group_name
  scopes              = local.vm_scope
  severity            = 3
  enabled             = true
  frequency           = "PT5M"
  window_size         = "PT5M"

  criteria {
    metric_namespace = "Microsoft.Compute/virtualMachines"
    metric_name      = "Network In Total"
    aggregation      = "Total"
    operator         = "GreaterThan"
    threshold        = 500000000000
  }

  action { action_group_id = azurerm_monitor_action_group.ag.id }
}

# Network Out Total > threshold (Total over 5m)
resource "azurerm_monitor_metric_alert" "net_out" {
  name                = "Network Out Total - ${var.virtualMachineName1}"
  resource_group_name = var.resource_group_name
  scopes              = local.vm_scope
  severity            = 3
  enabled             = true
  frequency           = "PT5M"
  window_size         = "PT5M"

  criteria {
    metric_namespace = "Microsoft.Compute/virtualMachines"
    metric_name      = "Network Out Total"
    aggregation      = "Total"
    operator         = "GreaterThan"
    threshold        = 200000000000
  }

  action { action_group_id = azurerm_monitor_action_group.ag.id }
}

# VM Availability < 1 (Average over 5m)
resource "azurerm_monitor_metric_alert" "availability" {
  name                = "VM Availability - ${var.virtualMachineName1}"
  resource_group_name = var.resource_group_name
  scopes              = local.vm_scope
  severity            = 3
  enabled             = true
  frequency           = "PT5M"
  window_size         = "PT5M"

  criteria {
    metric_namespace = "microsoft.compute/virtualmachines"
    metric_name      = "VmAvailabilityMetric"
    aggregation      = "Average"
    operator         = "LessThan"
    threshold        = 1
  }

  action { action_group_id = azurerm_monitor_action_group.ag.id }
}

###############################################################################
# Output (matches ARM output)
###############################################################################
output "adminUsername" {
  value = var.adminUsername
}
